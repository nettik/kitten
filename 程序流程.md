# Kitten Http Server整体设计
#### 初始化
+ 绑定地址并创建监听套接字描述符`socket_bind_listen`
+ 初始化并创建线程池`init_thread_pool`
    + 初始化线程池各个参数
    + 创建线程
    + 每个线程执行线程工作函数`thread_pool_work`
        + 每个线程首先对任务链表上互斥锁
        + 通过条件变量，判断任务链表中是否有任务，如果没有任务则阻塞在条件变量，并打开互斥锁
        + 如果有任务，则取出任务链表中第一个任务节点，从任务链表中删除该任务，并打开互斥锁
        + 开始执行该任务
        + 执行完毕释放任务节点
+ 创建epoll描述符，并将监听套接字描述符注册到epoll中
#### 处理请求
+ 如果描述符可读，并且该描述符是监听套接字描述符`handle_event`
    + 主线程调用`accept_connection`函数建立连接，并创建已连接描述符
    + 将已连接套接字描述符设置为非阻塞`make_socket_nonblock`
    + 向epoll中注册已连接描述符
+ 如果描述符可读，并且该描述符是已连接描述符`handle_event`
    + 通过`thread_pool_add_task`函数，将新建的任务加入线程池中
        + 任务处理函数为`do_request`，任务工作函数的参数为结构体`struct task_para`
        + 对任务链表加上互斥锁，并加新建的任务加点添加到任务链表中，任务链表的长度加1
        + 通过`pthread_cond_signal`函数唤醒一个阻塞在条件变量上的线程，被唤醒的线程处理该任务
#### 线程处理请求的过程
当一个任务被加入任务链表中时，会通过条件变量唤醒一个工作线程，该线程通过`do_request`函数处理请求
+ 通过`receive_request_from_client`从已连接套接字描述符中读取请求报文
    + 数据读取时发生错误(errno不是EAGAIN)或者对端已经关闭连接，则关闭连接
    + 如果errno为EAGAIN，则终止循环，判断是否读取了报文，如果读取了报文则返回已读取的报文；如果没有则释放缓冲区
    + 当读取内容超过缓冲区大小时，则调用`realloc`函数将缓冲区大小分配为原来的两倍
    + 报文读取完毕后，返回请求报文
+ 创建`struct http_request_info`对象，首先解析请求行，获得请求方法、url等信息，并填充结构体对象，接着按行解析首部字段，获取相关信息
+ 判断请求报文是否合法，如果不合法，则关闭连接
+ 根据`struct http_request_info`对象中文件路径等信息，将客户端请求的静态页面发送给客户端
+ 判断`struct http_request_info`对象中的`connect_status`参数是否为close，如果是，则关闭连接
